在梳理代码逻辑之前，首先介绍几个比较重要的结构：&nbsp;&nbsp;消息头包含的内容：&nbsp;&nbsp;网络传输中，所有消息的消息头格式是一样的，下面解释一下每一个消息头具体包含哪些内容：&nbsp;&nbsp;getdata/inv消息类型。这些号码由协议定义。消息类型大致分为：MSG_TX交易信息MSG_BLOCK区块MSG_FILTERED_BLOCK过滤的区块MSG_CMPCT_BLOCK紧凑区块//bip152&nbsp;&nbsp;&nbsp;&nbsp;当需要获取inventory时，发送此命令，发送时，需要指定范围。接收到此命令后，按指定范围获取inventory数据(PushGetBlocks)。Inv消息的示例：getdata：getdata消息请求来自另一个节点的一个或多个数据对象。这些对象由一个inventory请求，请求节点通常通过inv消息预先接收这些对象。对getdata消息的响应可以是tx消息，阻塞消息，merkleblock消息或未找到的消息。getdata不能用于请求任意数据，例如不再存在于内存池中的一些历史交易。如果全节点已经从其block数据库中打包了先前的交易，这时全节点可能无法提供这些block。出于这个原因，getdata消息通常只能通过发送inv消息向先前通告它的节点请求数据。getdata消息的格式和最大大小限制与inv消息相同，但是消息标题不同。merkleblock：如BIP37所述，在协议版本70001中添加。merkleblock消息是对使用inventory类型MSG_MERKLEBLOCK请求块的getdata消息的回复。这只是答复的一部分：如果找到任何匹配的交易，它们将作为tx消息单独发送。如果之前已经使用过滤器加载消息设置了过滤器，则merkleblock消息将包含所请求块中与过滤器匹配的所有事务的TXID以及将这些事务连接到块头的必要块所需的块merkle树的任何部分merkle根。该消息还包含块头的完整副本，以允许客户端对其进行hash并确认其工作证明。merkleblock消息示例：getblocksgetblocks消息请求一个inv消息，该消息提供从块链中的特定点开始的块头hash。区块同步时，发送此命令，发送时需要指定区块范围(PushGetBlocks)。接收到此命令后，根据区块范围，获取相应的区块，反馈回去。接收的数据中包含区块范围的开始区块的定位信息(CBlockLocator)、结束区块的索引，从开始区块的下一个区块开始。每次最多获取500个区块信息。满500个时，记录获取的最后一个区块的hahs值，保存到源节点的hashContinue中。示例如下：getheadersgetheaders消息请求headers消息，该消息提供从块链中的特定点开始的块header。接收到此命令后，获取指定的范围的区块的头，将headers消息发送给源节点。getheaders消息几乎与getblocks消息相同，只有一点区别：对getblocks消息的inv回复将包含不超过500个块头hash;headers回复getheaders消息将包含多达2000个块headers。txtx消息以原始交易格式传输单个交易。它可以在各种情况下发送;-交易响应：BitcoinCore和BitcoinJ将发送它以响应getdata消息，该消息请求inventory类型为MSG_TX的交易。-MerkleBlock响应：BitcoinCore将发送它以响应getdata消息，该消息请求inventory类型为MSG_MERKLEBLOCK的merkle块。（这是发送merkleblock消息的补充。）在这种情况下，每个tx消息提供该块的匹配交易。-Unsolicited：BitcoinJ会发送一个tx消息来主动发起它的交易。headersheaders消息将blockmessage发送到先前用getheaders消息请求特定headers的节点。headers消息可以是空的。示例如下：blockblockmessage以serializedblockssection描述的格式发送单个serializedblock。-获取数据响应：节点将始终发送它以响应一个getdata消息，该消息请求存储类型为MSG_BLOCK的块（假设该节点具有可用于发送的该块）。-主动提供：一些矿工会发送未经请求的block信息，将他们新挖掘的块块广播给他们的所有同行。许多矿池做同样的事情，虽然有些可能被错误地配置为从多个节点发送块，可能不止一次地将同一块发送给别的节点。notfoundnotfound的消息是对getdata消息的回复，该消息请求接收节点没有可用于发送的对象。（预计节点不会传递不再存在于内存池或发送集中的历史事务，节点也可能从较旧的块中删除已用完的事务，使它们无法发送这些块。）notfound消息的格式和最大大小限制与inv消息相同,只有消息的headers不同。mempoolmempool消息请求接收节点已验证为有效但尚未出现在块中的交易的TXID。也就是说，在接收节点的内存池中的交易。对mempool消息的响应是一个或多个包含inventory格式的TXID的inv消息。当程序首次连接到网络时，发送mempool消息非常有用。全节点可以使用它来快速收集网络上可用的大部分或全部未确认的交易;这对试图收取交易费用的矿工尤其有用。SPV客户端可以在发送mempool之前设置过滤器，以仅接收与该过滤器匹配的交易;这允许最近开始的客户获得与其钱包有关的大部分或全部未确认的交易。对mempool消息的inv响应充其量只是一个节点的网络视图–而不是网络上未经确认的交易的完整列表。以下是列表可能不完整的一些其他原因：-在BitcoinCore0.9.0之前，对mempool消息的响应只有一个inv消息。inv消息被限制为50,000个库存，所以具有大于50,000个条目的内存池的节点不会发送所有内容。BitcoinCore的更新版本根据需要发送尽可能多的inv消息以引用其完整的内存池。-mempool消息当前不与filterload消息的BLOOM_UPDATE_ALL和BLOOM_UPDATE_P2PUBKEY_ONLY标志完全兼容。-mempool消息当前不与filterload消息的BLOOM_UPDATE_ALL和BLOOM_UPDATE_P2PUBKEY_ONLY标志完全兼容。Mempool交易不像块内交易那样排序，因此一个消耗输出的交易（tx2）可以出现在包含该输出的交易（tx1）之前，这意味着自动过滤器更新机制将不会运行，直到第二次出现的交易tx1）–缺少首次出现的交易（tx2）。在BitcoinCoreissue#2381中已经提出，交易在被过滤器处理之前应该被排序。以上是对DataMessages的描述，其关系图如下：version:version消息在连接开始时向接收节点提供关于发送节点的信息。在这两个节点交换version消息之前，不会接受其他消息。当接收节点收到version消息之后，会回复给发送节点一个verack消息，同时把所有警告也反馈回去。但是在version消息的初始化未完成之前，是不会发送verack消息的。发送端只能发送一次获取版本的命令，重复发送时，回应拒绝命令(reject)。发送命令后，会把发送节点的地址信息添加到节点的地址管理器中。示例如下：verack：verack消息确认先前收到的版本消息，通知连接节点它可以开始发送其他消息。接收到版本回应命令后，设置节点的接收版本。与此同时，设置接收版本号，节点的接收版本(nRecvVersion)、接收消息的报头流的版本号、接收消息数据流的版本号(nVersion)都要设置。adddr：addr（IP地址）消息用来表示网络上节点的连接信息。每个想要接受传入连接的节点创建一个addr消息，提供其连接信息，然后将该消息发送给未经请求的节点，当接收端收到此命令后把接收到的地址添加到节点的地址管理器中，发送、接收的地址数量最多1000个。Pingping消息有助于确认接收方仍处于连接状态(判断网络是否连通)。如果在发送ping消息时遇到TCP/IP错误（例如连接超时），则发送节点可以假设接收节点已断开连接。对ping消息的响应是pong消息。在协议版本60000之前，ping消息没有payload。从协议版本60001及所有更高版本开始，消息包含一个字段即nonce。ping消息的nonce字段，示例如下：pongpong消息回复ping消息，向pinging节点证明ponging节点仍然存在。默认情况下，BitcoinCore将在20分钟内断开任何未响应ping消息的客户端。接收到pong命令后，更新节点的ping花费时间(nPingUsecTime)，所花费的时间为当前时间与节点的ping开始时间(nPingUsecStart)的差。为了允许节点跟踪等待时间，pong的回复消息中所包含的nonce字段与ping消息的nonce是相同的。pong消息的格式与ping消息相同;只有消息头不同。reject发生特殊情况时，reject消息通知接收节点其先前消息之一已被拒绝。特殊情况如下:-重复发送获取版本信息的命令(”version”)。-发送端的版本号大于最大版本号(MIN_PEER_PROTO_VERSION=209)。-接收到DDoS攻击。-处理消息时发生异常(ProcessMessage)。发送拒绝命令时，带上参数，表示拒绝的原因。SendHeaderssendheaders消息告诉接收方使用headers消息而不是inv消息发送新的块通告，具体可参照bip130。GetAddrgetaddr消息请求来自接收节点的addr消息，最好是具有大量其他接收节点的IP地址的消息。发送节点可以使用这些IP地址来快速更新其可用节点的数据库，而不是等待未经请求的addr消息随时间到达。接收到getaddr命令后把节点的地址管理器中的地址返回给发送端。先清空源节点的发送地址数组(vAddrToSend)。再把节点的IP地址管理器(addrman)中的地址(CAddress)发送给源节点。FeeFilterFeeFilter消息是对接收方的请求，不将任何交易inv消息转发给发送方，其中交易费率低于feefilter消息中指定的费率。在BitcoinCore0.12.0引入mempool限制之后，feefilter在BitcoinCore0.13.0中引入。Mempool限制功能可以防止费用较低的交易的攻击，并且不会将其纳入开采块中。feefilter消息告诉其他节点，如果你的费率低于我预先设置的费率，那你的这个交易是不允许进入我的mempool的，同时，这些节点就没必要继续把低于该费率的交易的inv消息转达给该节点。接收方可以选择不过滤这笔交易，直接忽略该消息。FeeFilter与bloom过滤器相加。如果SPV客户端加载bloom过滤器并发送FeeFilter消息，则只有通过两个过滤器才能转发交易。但请注意，feefilter对块传播或对getdata消息的响应没有影响。例如，如果一个节点通过发送一个包含inv类型MSG_FILTERED_BLOCK的getdata消息来请求一个merkleblock，并且它先前已经向该节点发送了一个feefilter，那么即使他们低于feefilter的费率，该节点也应该响应一个包含所有匹配bloom过滤器的交易的merkleblock。示例如下：FilterAddfilteradd消息告诉接收方将单个元素添加到先前设置的布隆过滤器，例如新的公共hash。该元素直接发送给接收方;然后其它节点使用在过滤器加载消息中设置的参数来将该元素添加到布隆过滤器。由于该元素直接发送到接收方，因此elem不会产生歧义，也不会出现布隆过滤器提供的似是而非的隐私。希望保持更高隐私性的客户端应自行重新计算布隆过滤器，并使用重新计算的布隆过滤器发送新的过滤器负载消息。注意：除非先前使用的filterload消息设置了过滤器，否则节点将不接受filteradd消息。示例如下：FilterClearfilterclear消息告诉接收方删除先前设置的bloom过滤器。这也消除了将版本消息中的转发字段设置为0的效果，允许未经过滤的访问广播新交易的inv消息。BitcoinCore在替换过滤器加载filterload之前不需要filterclear消息。它也不需要filterclear消息之前的filterload消息。FilterLoadfilterload消息告诉接收方需要过滤所有转发的交易，并通过提供的过滤器请求merkle块。这允许客户接收与其钱包相关的交易。示例如下：sendcmpctandcmpctblock、getblocktxn、blocktxn参照BIP152.以上是对ControlMessages的描述，其关系如下：下表列出了一些值得注意的P2P网络协议版本，其中最新版本列在第一位：