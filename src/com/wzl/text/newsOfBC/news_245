Fabric1.0源代码笔记之blockfile（区块文件存储）1、blockfile概述blockfile，即Fabric区块链区块文件存储，默认目录/var/hyperledger/production/ledgersData/chains，含index和chains两个子目录。其中index为索引目录，采用leveldb实现。而chains为各ledger的区块链文件，子目录以ledgerid为名，使用文件系统实现。区块文件以blockfile_为前缀，最大大小默认64M。blockfile，相关代码集中在common/ledger/blkstorage/fsblkstorage目录，目录结构如下：blockfile_mgr.go，blockfileMgr和checkpointInfo结构体及方法。block_stream.go，blockfileStream、blockStream、blockPlacementInfo结构体及方法。blockfile_rw.go，blockfileWriter和blockfileReader结构体及方法（blockfileReader未使用）。blockindex.go，index接口定义，index接口实现即blockIndex结构体及方法定义，以及blockIdxInfo、locPointer、fileLocPointer结构体及方法。blockfile_helper.go，定义了4个工具函数，constructCheckpointInfoFromBlockFiles、retrieveLastFileSuffix、isBlockFileName、getFileInfoOrPanic。作用分别为：扫描最新的blockfile并重新构造检查点信息、获取最新的文件后缀、根据文件前缀判断是否为区块文件、获取文件状态信息。block_serialization.go，block序列化相关工具函数。blocks_itr.go，blocksItr结构体及方法。2、Block结构体定、以及Block序列化2.1、Block相关结构体Block结构体：typeBlockstruct{Header*BlockHeader//BlockHeaderData*BlockData//BlockDataMetadata*BlockMetadata}func(m*Block)GetHeader()*BlockHeader//获取BlockHeader，即m.Headerfunc(m*Block)GetData()*BlockData//获取BlockData，即m.Datafunc(m*Block)GetMetadata()*BlockMetadata//m.Metadata//代码在protos/common/common.pb.goBlockHeader结构体：typeBlockHeaderstruct{Numberuint64//区块编号PreviousHash[]byte//前一个区块哈希DataHash[]byte//当前区块哈希}func(m*BlockHeader)GetNumber()uint64//获取区块编号，即m.Numberfunc(m*BlockHeader)GetPreviousHash()[]byte//获取前一个区块哈希，即m.PreviousHashfunc(m*BlockHeader)GetDataHash()[]byte//获取当前区块哈希，即m.DataHash//代码在protos/common/common.pb.goBlockData结构体：typeBlockDatastruct{Data[][]byte//Data，存储交易信息}func(m*BlockData)GetData()[][]byte//获取Data，即m.Data//代码在protos/common/common.pb.goBlockMetadata结构体：typeBlockMetadatastruct{Metadata[][]byte//K/V均为[]byte格式}func(m*BlockMetadata)GetMetadata()[][]byte//m.Metadata//代码在protos/common/common.pb.go补充BlockMetadataIndex：typeBlockMetadataIndexint32const(BlockMetadataIndex_SIGNATURESBlockMetadataIndex=0BlockMetadataIndex_LAST_CONFIGBlockMetadataIndex=1BlockMetadataIndex_TRANSACTIONS_FILTERBlockMetadataIndex=2BlockMetadataIndex_ORDERERBlockMetadataIndex=3)2.2、Block序列化serializedBlockInfo结构体定义及工具函数：typeserializedBlockInfostruct{blockHeader*common.BlockHeader//BlockHeadertxOffsets[]*txindexInfo//交易索引信息metadata*common.BlockMetadata}typetxindexInfostruct{txIDstring//交易IDloc*locPointer//文件指针}//序列化区块，返回序列化后字节，以及serializedBlockInfo（含BlockHeader和交易索引信息）funcserializeBlock(block*common.Block)([]byte,*serializedBlockInfo,error)//反序列化区块，构建Block结构体funcdeserializeBlock(serializedBlockBytes[]byte)(*common.Block,error)//反序列化区块，并构造serializedBlockInfofuncextractSerializedBlockInfo(serializedBlockBytes[]byte)(*serializedBlockInfo,error)//序列化中添加BlockHeader，即Number、DataHash和PreviousHashfuncaddHeaderBytes(blockHeader*common.BlockHeader,buf*proto.Buffer)error//序列化中添加BlockData，并从BlockData中解析txid，返回交易索引信息数组funcaddDataBytes(blockData*common.BlockData,buf*proto.Buffer)([]*txindexInfo,error)//序列化中添加MetadatafuncaddMetadataBytes(blockMetadata*common.BlockMetadata,buf*proto.Buffer)error//反序列化出BlockHeaderfuncextractHeader(buf*ledgerutil.Buffer)(*common.BlockHeader,error)//反序列化出BlockData，并返回交易索引信息数组funcextractData(buf*ledgerutil.Buffer)(*common.BlockData,[]*txindexInfo,error)//反序列化出MetadatafuncextractMetadata(buf*ledgerutil.Buffer)(*common.BlockMetadata,error)//从BlockData中解析出交易IDfuncextractTxID(txEnvelopBytes[]byte)(string,error)//代码在common/ledger/blkstorage/fsblkstorage/block_serialization.go3、checkpointInfo结构体定义及方法checkpointInfo，即检查点信息，结构体定义如下：typecheckpointInfostruct{latestFileChunkSuffixNumint//最新的区块文件后缀，如blockfile_000000latestFileChunksizeint//最新的区块文件大小isChainEmptybool//是否空链lastBlockNumberuint64//最新的区块编号}//代码在common/ledger/blkstorage/fsblkstorage/blockfile_mgr.go涉及方法如下：func(i*checkpointInfo)marshal()([]byte,error)//checkpointInfo序列化func(i*checkpointInfo)unmarshal(b[]byte)error//checkpointInfo反序列化func(i*checkpointInfo)String()string//转换为string//代码在common/ledger/blkstorage/fsblkstorage/blockfile_mgr.go4、blockfileStream相关结构体及方法4.1、blockfileStreamblockfileStream定义如下：typeblockfileStreamstruct{fileNumint//blockfile文件后缀file*os.File//os.Filereader*bufio.Reader//bufio.ReadercurrentOffsetint64//当前偏移量}//代码在common/ledger/blkstorage/fsblkstorage/block_stream.go涉及方法如下：//构造blockfileStreamfuncnewBlockfileStream(rootDirstring,fileNumint,startOffsetint64)(*blockfileStream,error)func(s*blockfileStream)nextBlockBytes()([]byte,error)//下一个块，调取s.nextBlockBytesAndPlacementInfo()//下一个块和位置信息func(s*blockfileStream)nextBlockBytesAndPlacementInfo()([]byte,*blockPlacementInfo,error)func(s*blockfileStream)close()error//关闭blockfileStream//代码在common/ledger/blkstorage/fsblkstorage/block_stream.gofunc(s*blockfileStream)nextBlockBytesAndPlacementInfo()([]byte,*blockPlacementInfo,error)代码如下：varlenBytes[]bytevarerrerrorvarfileInfoos.FileInfomoreContentAvailable:=truefileInfo,err=s.file.Stat()//获取文件状态remainingBytes:=fileInfo.Size()-s.currentOffset//文件读取剩余字节peekBytes:=8ifremainingBytes&lt;int64(peekBytes){//剩余字节小于8，按实际剩余字节，否则按8peekBytes=int(remainingBytes)moreContentAvailable=false}//存储形式：前n位存储block长度length，之后length位为实际blocklenBytes,err=s.reader.Peek(peekBytes)//Peek返回缓存的一个切片，该切片引用缓存中前peekBytes个字节的数据length,n:=proto.DecodeVarint(lenBytes)//从切片中读取varint编码的整数，它返回整数和被消耗的字节数。err=s.reader.Discard(n)//丢弃存储block长度length的前n位blockBytes:=make([]byte,length)_,err=io.ReadAtLeast(s.reader,blockBytes,int(length))blockPlacementInfo:=&amp;blockPlacementInfo{fileNum:s.fileNum,blockStartOffset:s.currentOffset,blockBytesOffset:s.currentOffset+int64(n)}s.currentOffset+=int64(n)+int64(length)returnblockBytes,blockPlacementInfo,nil//代码在common/ledger/blkstorage/fsblkstorage/block_stream.go补充blockPlacementInfo：块位置信息typeblockPlacementInfostruct{fileNumint//块文件后缀blockStartOffsetint64//n+length，n之前blockBytesOffsetint64//n+length，length之前}//代码在common/ledger/blkstorage/fsblkstorage/block_stream.go5、blockfileWriter结构体定义及方法typeblockfileWriterstruct{filePathstring//路径file*os.File//os.File}funcnewBlockfileWriter(filePathstring)(*blockfileWriter,error)//构造blockfileWriter，并调用writer.open()func(w*blockfileWriter)truncateFile(targetSizeint)error//截取文件func(w*blockfileWriter)append(b[]byte,syncbool)error//追加文件func(w*blockfileWriter)open()error//打开文件func(w*blockfileWriter)close()error//关闭文件//代码在common/ledger/blkstorage/fsblkstorage/blockfile_rw.go6、blockIndex相关结构体及方法6.1、index接口定义typeindexinterface{getLastBlockIndexed()(uint64,error)//获取最后一个块索引（或编号）indexBlock(blockIdxInfo*blockIdxInfo)error//索引区块getBlockLocByHash(blockHash[]byte)(*fileLocPointer,error)//根据区块哈希，获取文件区块指针getBlockLocByBlockNum(blockNumuint64)(*fileLocPointer,error)//根据区块编号，获取文件区块指针getTxLoc(txIDstring)(*fileLocPointer,error)//根据交易ID，获取文件交易指针getTXLocByBlockNumTranNum(blockNumuint64,tranNumuint64)(*fileLocPointer,error)//根据区块编号和交易编号，获取文件交易指针getBlockLocByTxID(txIDstring)(*fileLocPointer,error)//根据交易ID，获取文件区块指针getTxValidationCodeByTxID(txIDstring)(peer.TxValidationCode,error)//根据交易ID，获取交易验证代码}//代码在common/ledger/blkstorage/fsblkstorage/blockindex.go6.2、blockIndex结构体blockIndex结构体定义如下：typeblockIndexstruct{indexItemsMapmap[blkstorage.IndexableAttr]bool//index属性映射db*leveldbhelper.DBHandle//indexleveldb操作}//代码在common/ledger/blkstorage/fsblkstorage/blockindex.go补充IndexableAttr：const(IndexableAttrBlockNum=IndexableAttr(\"BlockNum\")IndexableAttrBlockHash=IndexableAttr(\"BlockHash\")IndexableAttrTxID=IndexableAttr(\"TxID\")IndexableAttrBlockNumTranNum=IndexableAttr(\"BlockNumTranNum\")IndexableAttrBlockTxID=IndexableAttr(\"BlockTxID\")IndexableAttrTxValidationCode=IndexableAttr(\"TxValidationCode\"))//代码在common/ledger/blkstorage/blockstorage.go未完待续欢迎继续关注兄弟连区块链教程分享!